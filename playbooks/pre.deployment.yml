####################################################################
#### gel.readiness.yml                                          ####
####################################################################
#### Author: Erwan Granger, GEL                                 ####
#### Date: 2017.01.04                                           ####
#### Version: 1.26                                              ####
####  WARNING: this playbook only works                         ####
####           with Ansible 2.2 and above.                      ####
####################################################################
#### CHANGELOG:                                                 ####
####    2017.01.04: EG: start work on version for 17w12         ####
####    2017.05.05: EG: re-work the structure and the checks    ####
####    2017.06.22: EG: clean up some of the stray variables    ####
####    2017.08.02: EG: changed the way cores are counted       ####
####                    added a check for number of network interfaces
####    2017.08.09: EG: adding tooling for version and solution ####
####                    moving packages to variable lists       ####
####                    adding a hostname=hostname -f check     ####
####    2017.08.21: EG: re-working the user/group section       ####
####                    clean up of equal signs.                ####
####                                                            ####
####                                                            ####
####                                                            ####
####                                                            ####
####################################################################

####################################################################
#### DISCLAIMER                                                 ####
####################################################################
#### This Ansible Playbook is provided as-is, without warranty  ####
#### of any kind, either express or implied, including, but not ####
#### limited to, the implied warranties of merchantability,     ####
#### fitness for a particular purpose, or non-infringement.     ####
#### SAS Institute shall not be liable whatsoever for any       ####
#### damages arising out of the use of this documentation and   ####
#### code, including any direct, indirect, or consequential     ####
#### damages. SAS Institute reserves the right to alter or      ####
#### abandon use of this documentation and code at any time.    ####
#### In addition, SAS Institute will provide no support for the ####
#### materials contained herein.                                ####
####################################################################


####################################################################
# this playbook verifies and possibly performs many of the pre-requisites for a generic Viya deployment.
# it assumes that all machines need to be identical, which is an over-simplification, but has advantages.
#
# to see an index of the things it does, run:
#        ansible-playbook gel.readiness.yml --list-tasks
# to see how far from the desired state you are, run:
#        ansible-playbook gel.readiness.yml --check
# to let the playbook make all the required changes and bring you to the desired state, run:
#        ansible-playbook gel.readiness.yml
#
# useful tags to know:
#  - skipifbelowspecs: allows the playbook to run even if your servers do not meet the specs (CPU, Mem, Storage)
#         If you server(s) fails one of the specs tests, the error message will tell you how to bypass that check.
#  - detectableonly: tasks where we can detect the wrong or right config, but can't fix it
#  - fixable:  tasks where we can both
####################################################################


---
- hosts: all
  become: yes
  become_user: root

  vars:

    ## local users ##
    create_local_cas_and_sas_accounts: true
    cas_user: cas
    sas_user: sas
    sas_group: sas
    umask_value: "0002"
    custom_group_list:
      - { group: "{{sas_group}}",       gid: 1001 }

    custom_user_list:
      - { name: "{{cas_user}}" , uid: 1001 ,  group: "{{sas_group}}",  groups: "{{sas_group}}"}
      - { name: "{{sas_user}}" , uid: 1002 ,  group: "{{sas_group}}",  groups: "{{sas_group}}"}


    ## storage ##
    storage_list:
      # please update as needed.
      - { path: /, min_storage_mb: 5000, min_io: 2}
      - { path: /opt/sas, min_storage_mb: 40000, min_io: 2}
      # add more lines to check more partitions. For example:
      #- { path: /sastmp, min_storage_mb: 4000, min_io: 99}

    ## Minimum total Memory on each machine
    min_mem_mb: 40000

    ## Minimum number of cores on each machine
    min_cores_num: 4


    # SSH Max Startups
    maxstartups_val: 100

    # ulimit values
    ulimit_nofile_val: 20480
    ulimit_soft_nproc_val: 65536

    #max_hostname_length: 64       ## official number from the doc
    max_hostname_length: 58        ## better number, SAS note is yet to be written.

    ## version-specific and solution-specific
    viya_version: 3.2

    ## to run the readiness steps for a VA/VS/VDMML environment:
    solution_va_vs_vdmml: true
    ## to run the readiness steps for a VI environment:
    solution_vi: false

    ## VI has different ulimits
    ## these values have to be updated.
    vi_ulimit_nofile_val: 20480
    vi_ulimit_soft_nproc_val: 65536

    ## yum related
    yum_cache_yn: 0                ## do you want to turn the yum cache on or off? (1=on, 0=off)
    yum_cache_min_space_mb: 8000   ## how many MB of free space should be in /var/yum/cache ?

    ## general packages that are mandatory for Viya to work
    yum_packages_general:
      - java
      - numactl
      - libXp.x86_64
      - libXp.i686
      - libXext
      - libXmu
      - libXtst
      - xterm      ## this is required for the xterm functions from CAS Monitor
      - xorg-x11-xauth
      - strace     ## may be neeeded for hadooptracer
      - net-tools  ## you need to have netstat on the server
    yum_packages_nicetohave:
      - firefox       ## a browser on the server can be useful
      - xclock        ## can be used to test X11 display
      - mlocate       ## quicker way to find your files
      - wget
      #- python-passlib ## useful to encrypt passwords with python
      - curl
      - openldap-clients  ## very useful for testing AD/LDAP connection
      #- sshpass          ## sshpass can be problematic so ignore_errors has been added
      - python-firewall
      - lsof
      - tmux              ## help insure against accidental disconnections of SSH
    yum_packages_rhel6:
      - libpng
    yum_packages_rhel7:
      - libpng12

    ## these are the URLs of the SAS YUM repos.
    ## if your servers can not reach them, you are going to have to create a local YUM mirror
    sas_yum_urls:
      - ses.sas.download
      - bwp1.ses.sas.download
      - bwp2.ses.sas.download
      - sesbw.sas.download

    ## maximum number of network interfaces (excluding loopback)
    max_num_nics: 1

    ## do a 60 seconds pause at the begginning if not using the --check option
    use_pause: true

    ## not used.
    #admin_email: me@somewhere.com


  tasks:

#  - name: "WARNING: If you are running this playbook without the --check parameter, it WILL perform changes to your servers."
#    pause:
#      seconds: 60
#      prompt: "Press 'ctl+c' and then 'A' to abort the process. The playbook will continue after 60 seconds"
#    when: (ansible_check_mode == False) and (use_pause == True)
#    tags:
#      - always



####################################################################
## About the sections
##    - First the things that can be detected but not changed by the playbook
##    - second, the things that can be detected and changed by the playbook
##
####################################################################


####################################################################
## Ping
####################################################################
  - name: Ping all the servers
    ping:
    tags:
      - ping


####################################################################
## Verify memory
####################################################################
# Test harness:
#   make it pass
#     ansible-playbook gel.readiness.yml -e "use_pause=0" --tags memory -e "min_mem_mb=1"
#   make it fail
#     ansible-playbook gel.readiness.yml --tags memory -e "use_pause=0" -e "min_mem_mb=9999999"

  - block:
    ## Display all the values:
    - name: Query the Server Memory for all servers being used in deployment
      setup:
        filter: "*memory*"
      register: memory

    - name: Show all memory info gathered by Ansible
      debug: var=memory

    - name: Show total memory info
      debug: msg="Total Memory is {{ ansible_memory_mb.real.total }} MB"
    - name: Show free memory info
      debug: msg="Free  Memory is {{ ansible_memory_mb.real.free }} MB"

    - name: Assert that there is enough ({{(min_mem_mb|int)/1000}} GB) memory on the server
      assert:
        that:
          - ( ansible_memory_mb.real.total | int ) >= ( min_mem_mb | int )
        msg:
          - "This server should have at least {{(min_mem_mb | int) / 1000}} GB of total memory."
          - "It only has {{( ansible_memory_mb.real.total | int) / 1000}} GB."
          - "Add --skip-tags skipmemfail to bypass"
      tags:
        - skipifbelowspecs
        - skipmemfail
    ## block end
    tags:
      - memory
      - detectableonly

####################################################################
## Verify cores
####################################################################
# Test harness:
#   make it pass
#     ansible-playbook gel.readiness.yml --tags cores -e "use_pause=0" -e "min_cores_num=1"
#   make it fail
#     ansible-playbook gel.readiness.yml --tags cores -e "use_pause=0" -e "min_cores_num=100"

  - block:
    - name: Querying CPUs
      setup:
        filter: "ansible_processor*"
      register: processors
    - name: Show the processor information gathered by Ansible
      debug: var=processors.ansible_facts

    - name: Querying detailed CPU info from /proc/cpuinfo
      shell: "cat /proc/cpuinfo"
      changed_when: False
      check_mode: no
      register: detailedcpuinfo
    - name: Show the detailed cpu info from /proc/cpuinfo
      debug: var=detailedcpuinfo.stdout_lines


    - name: Querying number of CPUs from /proc/cpuinfo
      # commenting out because this does not work well on OpenStack
      #shell: "cat /proc/cpuinfo | grep 'cpu cores' | uniq | awk -F'[:]' '{print $2}' "
      # instead, I found this command which seems to work better. https://access.redhat.com/discussions/480953
      ## note that this does not seem to work on Oracle Linux. :-(
      shell: "egrep -e 'core id' -e ^physical /proc/cpuinfo|xargs -l2 echo|sort -u | wc -l"
      changed_when: False
      check_mode: no
      register: cpuinfo
    - name: Show the number of CPUs
      debug: var=cpuinfo.stdout


    - name: Assert that there are enough ({{min_cores_num}}) cores on the server
      assert:
        that:
          - (cpuinfo.stdout | int) >= (min_cores_num | int)
        msg:
          - "This server should have at least ({{min_cores_num}}) cores."
          - "It only has {{(cpuinfo.stdout | int)}} core(s)."
          - "Add --skip-tags skipcoresfail to bypass."
      tags:
        - skipifbelowspecs
        - skipcoresfail
    ## block end
    tags:
      - cores
      - cpu
      - detectableonly



####################################################################
## Storage
####################################################################
  - block:
    ## evaluate each of the paths in the storage list

# Test harness (not working):
#   make it pass
#     ansible-playbook gel.readiness.yml --tags storage -e "use_pause=0" --extra-vars '{"storage_list": {  "path": "/" , "min_storage_mb": 1 , "min_io": 1 } }'
#   make it fail

    - name: Query the storage for all servers being used in deployment
      setup:
        filter: "*mount*"
      register: mount
    - name: Show the mountpoint information gathered by Ansible
      debug: var=mount

    - name: "Make sure all directories exist, create them if needed"
      file:
        path: "{{ item.path }}"
        state: directory
      with_items: "{{storage_list}}"

    - name: "Get status for directories"
      stat:
        path: "{{ item.path }}"
      register: "directories_exists"
      with_items: "{{storage_list}}"

    - name: Show the status of directories
      debug: var=directories_exists

    - name: "Assert that directories exist, fail if they don't"
      assert:
        that:
          - item.stat.exists and item.stat.isdir
        msg:
          - "The directory {{item.item.path}} does not exist on this server."
          - "Edit the storage_list variable if this is a mistake."
          - "Or add --skip-tags skipstoragefail to bypass"
      with_items:
        - "{{directories_exists.results}}"
      tags:
        - skipifbelowspecs
        - skipstoragefail


    - name: Get the amount of free disk space (in MB) of each directory.
      shell: df -Ph "{{ item.item.path }}" --block-size=M | tail -1 | awk '{print $4}' | sed 's/[^0-9]*\([0-9]\+\)[^0-9]*/\1/'
      changed_when: False
      check_mode: no
      with_items:
        - "{{directories_exists.results}}"
      register: df_result
    - name: Show the results of the df command
      debug: var=df_result

    - name: "Assert that directories have enough free space"
      assert:
        that:
          - (item.stdout | int) >= (item.item.item.min_storage_mb | int)
        msg:
        - "The directory {{item.item.item.path}} only has {{(item.stdout | int) / 1000}} GB of free space."
        - "It should have at least {{(item.item.item.min_storage_mb | int) / 1000}} GB."
        - "Edit storage_list if this is a mistake."
        - "Or add --skip-tags skipstoragefail to bypass"
      with_items:
        - "{{df_result.results}}"
      tags:
        - skipifbelowspecs
        - skipstoragefail
## we need smarter checks:
  ## that /opt/sas and / are not the same partition
  ## ...

    - name: Get the device associated with all the directories.
      shell: df "{{ item.path }}" | tail -1 | awk '{print $1}'
      changed_when: False
      check_mode: no
      register: device_list
      with_items: "{{storage_list}}"
      tags:
        - storagedev

    - name: Show the device information
      debug: var=device_list.results
      tags:
        - storagedev
#    - name: Display devices
#      debug: var=device_list.results.[].stdout
#      tags:
#        - storagedev

#    - name: Display devices
#      debug: msg="the list has a lenght of {{device_list.results | count}}"
#      tags:
#        - storagedev

#    - name: Display devices
#      debug: msg="the list has a lenght of unique {{device_list.results | unique | count}}"
#      tags:
#        - storagedev

    ## end of block
    tags:
      - storage
      - detectableonly


####################################################################
## Verify hostname length
####################################################################

  - block:
    ## hostname block
      ## hostname can't be too long
    - name: Capture the length of the hostname
      shell: "hostname  | wc -c"
      changed_when: False
      check_mode: no
      register: hostname_length

    - name: Show the hostname length
      debug: var=hostname_length.stdout
    - name: Show the maximum desired hostname length
      debug: var=max_hostname_length

    - name: "Assert that hostname is not too long (less than {{max_hostname_length}} characters"
      assert:
        that:
          - (hostname_length.stdout | int) <= (max_hostname_length | int)
        msg:
          - "The hostname is too long."
          - "Yours is {{hostname_length.stdout | int}} characters long. It should be {{max_hostname_length}} characters or less."
          - "Add --skip-tags skipnamelengthfail to bypass"
      tags:
        - skipnamelengthfail

      ## if hostname and hostname -f don't return the same thing, rabbit causes issues.
    - name: Get the value of hostname
      shell: "hostname"
      changed_when: False
      check_mode: no
      register: normal_hostname

    - name: Get the value of hostname -f
      shell: "hostname -f"
      changed_when: False
      check_mode: no
      register: full_hostname

    - name: "Assert that <hostname> and <hostname -f> return the same result"
      assert:
        that:
          - (normal_hostname.stdout ) == (full_hostname.stdout)
        msg:
          - "Your hostname value ({{normal_hostname.stdout}}) is different from your full hostname ({{full_hostname.stdout}})."
          - "This can cause issue with the deployment of rabbitmq"
          - "Add --skip-tags skipnamematchfail to bypass"
      tags:
        - skipnamematchhfail

    ## end of hostname block
    tags:
      - hostname
      - detectableonly






####################################################################
## yum cache config
####################################################################


  - block:

    - name: Show message telling you that you wanted YUM cache 'on'
      debug: msg="You want YUM cache enabled"

    - name: Getting the amount of free disk space (in MB) in the /var/cache/yum directory.
      shell: df -Ph /var/cache/yum  --block-size=M | tail -1 | awk '{print $4}' | sed 's/[^0-9]*\([0-9]\+\)[^0-9]*/\1/'
      changed_when: False
      check_mode: no
      register: var_cache_yum_actual

    - name: Show information about YUM cache storage
      debug: msg="You have {{var_cache_yum_actual.stdout}} MB free in /var/cache/yum and you need {{yum_cache_min_space_mb}} MB free"


    - name: "Assert that there is enough space for YUM cache"
      assert:
        that:
          - var_cache_yum_actual.stdout | int > yum_cache_min_space_mb | int
        msg:
          - "There is only {{var_cache_yum_actual.stdout | int}} MB available for YUM cache."
          - "You need at least {{yum_cache_min_space_mb}} MB"
          - "Either add more space or set the yum_cache_yn to 0."
          - "Add --skip-tags skipyumspacefail to bypass"
      tags:
        - skipifbelowspecs
        - skipyumspacefail


    when:  yum_cache_yn | bool  == true
    tags:
      - yumcache
      - detectableonly

  ## If the location of the YUM cache (/var/cache/yum) has the space for it (10-15 GB), set this to 1
  ## If not, leave this to zero
  - name: Enable/disable YUM caching ({{yum_cache_yn}})
    lineinfile:
      dest=/etc/yum.conf
      regexp="^keepcache="
      line="keepcache={{yum_cache_yn}}"
    tags:
      - yumcache
      - fixable


####################################################################
## OS versions check
####################################################################
  - name: Ensure that the OS is supported for VA 8.1
    fail: msg="It looks like your OS ({{ansible_os_family}} {{ansible_distribution_version}}) does not match the VA 8.1 minimum requirements."
    when: (ansible_os_family != 'RedHat')
      or (ansible_distribution_major_version == '7' and ansible_distribution_version < '7.1')
      or (ansible_distribution_major_version == '6' and  ansible_distribution_version < '6.7')
    tags:
      - OS

####################################################################
## SSH MaxStartups parameter
####################################################################
## read more about SSH maxstartups at:
## https://stackoverflow.com/questions/4812134/in-sshd-configuration-what-is-maxstartups-103060-means

    ## block start
  - block:
    - name: Capture current SSH maxstartups value (third one)
      shell: "sshd -T | grep maxstartups | awk -F'[: ]' '{print $4}'"
      changed_when: False
      check_mode: no
      register: cur_maxstartups_3

    - name: Show the current value for sshd MaxStartups
      debug: var=cur_maxstartups_3.stdout


    ## case 1: current value is bigger, we leave as-is
    - block:
      - name: Show message when we leave maxstartups untouched
        debug: msg="Your current maxstartups value ({{cur_maxstartups_3.stdout}}) is larger or equal than the desired maxstartups value ({{maxstartups_val}}) \n We won't udpate the maxstartups value"
      when: cur_maxstartups_3 is defined and ((cur_maxstartups_3.stdout | int) > maxstartups_val|int)

    ## case 2: current value is smaller, we update
    - block:
      - name: Show message when we update maxstartups
        debug: msg="your current maxstartups value ({{cur_maxstartups_3.stdout}}) is smaller or equal than the desired maxstartups value ({{maxstartups_val}})"

      - name: Capture current SSH maxstartups value (first one)
        shell: "sshd -T | grep maxstartups | awk -F'[: ]' '{print $2}'"
        changed_when: False
        check_mode: no
        register: cur_maxstartups_1

      - name: Capture current SSH maxstartups value (second one)
        shell: "sshd -T | grep maxstartups | awk -F'[: ]' '{print $3}'"
        changed_when: False
        check_mode: no
        register: cur_maxstartups_2

      - set_fact: newsshline="MaxStartups {{cur_maxstartups_1.stdout}}:{{cur_maxstartups_2.stdout}}:{{maxstartups_val}}"
      - name: show the new line to be inserted in sshd_config
        debug: var=newsshline

      - name: Configure SSH with MaxStartups={{maxstartups_val}} in /etc/ssh/sshd_config
        lineinfile:
          dest: /etc/ssh/sshd_config
          regexp: "^MaxStartups"
          line: "{{newsshline}}"
          state: present
          backup: yes
        register: sshd_config

      - name: Show the results of the lineinfile action on maxstartups
        debug: var=sshd_config

      - name: We restart the SSHD service
        service:
          name: sshd
          state: restarted
        when: sshd_config.changed

      when: cur_maxstartups_3 is defined and ((cur_maxstartups_3.stdout | int) < maxstartups_val|int)

    ## block end
    tags:
      - ssh
      - fixable


####################################################################
## Packages
####################################################################

    ## block start
  - block:

    ## works for either RHEL 6 or RHEL 7
    - name: Ensures required packages are present
      yum:
        name: "{{ item }}"
        state: present
      with_items:
        - "{{yum_packages_general}}"
      tags:
        - packages

    ## RHEL 6 specific
    - name: Ensures required RHEL6 packages are present
      yum:
        name: "{{ item }}"
        state: present
      with_items:
        - "{{yum_packages_rhel6}}"
      when: ansible_distribution_major_version == '6'
      tags:
        - packages

    ## RHEL 7 specific
    - name: Ensures required RHEL7 packages are present
      yum:
        name: "{{ item }}"
        state: present
      with_items:
        - "{{yum_packages_rhel7}}"
      when: ansible_distribution_major_version == '7'
      tags:
        - packages

    ## we need systemd to be above 219-30
    ## try to make sure we have the latest one.
    - name: Ensures systemd package is the most recent
      yum:
        name: systemd
        state: latest
      when: ansible_distribution_major_version == '7'
      tags:
        - packages




    - name: Ensures "nice to have" packages are present
      yum:
        name: "{{ item }}"
        state: present
      ignore_errors: yes
      with_items:
        - "{{yum_packages_nicetohave}}"
      tags:
        - packages
        - nicetohave

  # On Linux 7.x, verify that the systemd package on each machine is at version 219-30 or later.
    - block:
      ## this code needs to be improved.
      ## it looks for version 219 only. lower or higher will fail.
      - name: obtain systemd version
        shell: systemctl --version | head -n 1
        register: systemd_version
        changed_when: False
        check_mode: no

      - name: Display systemd version
        debug: var=systemd_version
        #when: systemd_version.stdout != "systemd 219"

      - name: "Unexpected version of systemd: {{ system_version.stdout }}. Failing the playbook"
        fail:
        when: systemd_version.stdout != "systemd 219"

      when: ansible_distribution_major_version == '7'
      tags:
        - systemd
        - packages

    ## block end
    tags:
      - packages
      - fixable



####################################################################
## SELINUX
####################################################################

  - name: Disable SELinux (will only take effect after a reboot)
    ## this could also be set to permissive
    lineinfile:
      dest: /etc/selinux/config
      regexp: "^SELINUX=.*"
      line: "SELINUX=permissive"
      state: present
      backup: yes
    tags:
      - selinux

  - name: Get selinux status
    shell: /usr/sbin/getenforce
    changed_when: False
    check_mode: no
    register: selinuxstatus
    tags:
      - selinux

  - name: Make SELinux permissive (in the current session) but only if it's currently enabled
    shell: "setenforce 0"
    when: selinuxstatus.stdout is defined and  selinuxstatus.stdout == 'Enforcing'
    ignore_errors: yes
    tags:
      - selinux




####################################################################
## OS-level Firewalls
####################################################################

## on RHEL 7, we make sure that firewalld is disabled and stopped
  - name: Check if firewalld exists
    stat:
      path: /usr/lib/systemd/system/firewalld.service
    register: firewall_status
    tags:
      - firewall

  - name: Disable firewalld (on RHEL 7)
    service:
      name: firewalld
      enabled: no
      state: stopped
    when: ansible_distribution_major_version == '7' and firewall_status.stat.exists
    tags:
      - firewall

## on RHEL 6, we deal with iptables and iptables6
  - name: Disable iptables (on RHEL 6)
    service:
      name: iptables
      enabled: no
      state: stopped
    when: ansible_distribution_major_version == '6'
    ignore_errors: yes
    tags:
      - firewall

  - name: Disable ip6tables (on RHEL 6)
    service:
      name: ip6tables
      enabled: no
      state: stopped
    when: ansible_distribution_major_version == '6'
    ignore_errors: yes
    tags:
      - firewall



####################################################################
## groups and users
####################################################################

      ## block start
  - block:

## proto-code
##    first, do no harm
##      if wanted gid is already given to other group, cancel
##      if wanted group already exists but has wrong gid, cancel
##      same for user
##      if user already exists, and has right gid, don't change group membership (makes us less idempotent)
##      if you had no reason to exit so far, then
##        create group
##        create users




# draft test harness:

# this should fail quick because group name is already in use
#  ansible-playbook gel.readiness.yml --tags users -e "use_pause=0" --extra-vars '{"custom_group_list": {  "group": "root" , "gid":"2500"  }     }'
#  ansible-playbook gel.readiness.yml --tags users -e "use_pause=0" --extra-vars '{"custom_group_list": {  "group": "weirdname" , "gid":"0"  }     }'

#  ansible-playbook gel.readiness.yml --tags users -e "use_pause=0" --extra-vars '{"custom_group_list": {  "group": "sas" , "gid":"1001"  }     }'


## we need a lot of error checking aroung the users, groups, uid, gid.
## commenting out for now.

      ## Check if the groups exist, and if so, what its gid is
    - name: Get the GID each group name
      shell:  "getent group {{item.group}} | awk -F'[:]' '{print $3}' "
      changed_when: False
      check_mode: no
      register: gather_gid
      failed_when: no
      with_items:
        - "{{ custom_group_list }}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - group
    - name: display the group
      debug: var=gather_gid
      when: create_local_cas_and_sas_accounts == true
      tags:
        - group

    - name: Assert that the groups either does not exist, or if it does, has the desired GID
      any_errors_fatal: true
      assert:
        that:
          - ( item.stdout == "" ) or (( item.stdout | int ) == ( item.item.gid | int))
        msg:
          - "We looked for the group '{{item.item.group}}'. (getent group {{item.item.group}})"
          - "We found that this group already exists and has a GID of {{item.stdout}}"
          - "We were expecting a GID of {{item.item.gid}}"
          - "Review the 'custom_group_list' variable."
      with_items:
        - "{{gather_gid.results}}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - group

      ## if we passed the previous check, we know that either:
        ## the group exists and has the right GID, or it does not exist at all
      ## Check if the groups exist, and if so, what its gid is
    - name: Get the group from the GID
      shell:  "getent group {{item.gid}} | awk -F'[:]' '{print $1}' "
      changed_when: False
      check_mode: no
      register: gather_group
      failed_when: no
      with_items:
        - "{{ custom_group_list }}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - group
    - name: display the group
      debug: var=gather_group
      when: create_local_cas_and_sas_accounts == true
      tags:
        - group

    - name: Assert that the either the GID is not used, or if used, it's used for the right group
      any_errors_fatal: true
      assert:
        that:
          - ( item.stdout == "" ) or (( item.stdout ) == ( item.item.group ))
        msg:
          - "We looked for the GID '{{item.item.gid}}'. (getent group {{item.item.gid}})"
          - "We found that this GID is already assigned but to the group '{{item.stdout}}'"
          - "We were expecting a group of '{{item.item.group}}'"
          - "Review the 'custom_group_list' variable."
      with_items:
        - "{{gather_group.results}}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - group

## if we got this far, it's safe to create/update the group.
    ## let's create the group
    - name: Ensure groups are present
      any_errors_fatal: true
      group:
        name: "{{ item.group }}"
        gid: "{{item.gid}}"
        state: present
      with_items:
        - "{{ custom_group_list }}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - group







## now we deal with the users.
    ## make sure the user either does not exist, or if it does, it has the right UID.
    - name: Get the UID for each user
      shell:  "getent passwd {{item.name}} | awk -F'[:]' '{print $3}' "
      changed_when: False
      check_mode: no
      register: gather_uid
      failed_when: no
      with_items:
        - "{{ custom_user_list }}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - users
    - name: display the uid
      debug: var=gather_uid
      when: create_local_cas_and_sas_accounts == true
      tags:
        - users

    - name: Assert that the user either does not exist, or if it does, has the desired UID
      any_errors_fatal: true
      assert:
        that:
          - ( item.stdout == "" ) or (( item.stdout | int ) == ( item.item.uid | int))
        msg:
          - "We looked for the user '{{item.item.name}}'. (getent passwd {{item.item.name}})"
          - "We found that this user already exists and has a UID of {{item.stdout}}"
          - "We were expecting a UID of {{item.item.uid}}"
          - "Review the 'custom_user_list' variable."
      with_items:
        - "{{gather_uid.results}}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - users




      ## Check if the user exist, and if so, what its gid is
    - name: Get the user name from the wanted UIDs
      shell:  "getent passwd {{item.uid}} | awk -F'[:]' '{print $1}' "
      changed_when: False
      check_mode: no
      register: gather_name
      failed_when: no
      with_items:
        - "{{ custom_user_list }}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - users
    - name: display the user names
      debug: var=gather_name
      when: create_local_cas_and_sas_accounts == true
      tags:
        - users

    - name: Assert that the either the UID is not used, or if used, it's used for the right user name
      any_errors_fatal: true
      assert:
        that:
          - ( item.stdout == "" ) or (( item.stdout ) == ( item.item.name ))
        msg:
          - "We looked for the UID '{{item.item.uid}}'. (getent group {{item.item.uid}})"
          - "We found that this UID is already assigned but to the user '{{item.stdout}}'"
          - "We were expecting a user of '{{item.item.name}}'"
          - "Review the 'custom_user_list' variable."
      with_items:
        - "{{gather_name.results}}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - users


    - name: Ensure users are present
      user:
        name: "{{ item.name }}"
        uid: "{{item.uid}}"
        group: "{{ item.group }}"
        groups: "{{ item.groups }}"
        append: yes
        state: present
      with_items:
         - "{{ custom_user_list }}"
      when: create_local_cas_and_sas_accounts == true
      tags:
        - users

    - name: Ensure umask are correctly set for users
      lineinfile:
        dest: "/home/{{ item[0].name }}/.bashrc"
        line: "{{ item[1] }}"
        state: present
        create: yes
      with_nested:
         - "{{ custom_user_list }}"
         - [ "# Set umask to 0002 instead of the default 0022, so that the default permissions for files", "# created by this user grant write permission to members of this user's primary group", "umask {{umask_value}}" ]
      when: create_local_cas_and_sas_accounts == true
      tags:
        - users

    ## block end
    tags:
      - usersandgroups







####################################################################
## Ulimits
####################################################################

  ## only do this if the CAS user exist. If not, skip the whole thing.
  - name: check if the cas account exitst
    shell:  "getent passwd {{cas_user}} > /dev/null "
    changed_when: False
    check_mode: no
    register: check_cas_user
    failed_when: false
#    failed_when: >
#      not (
#      check_cas_user.rc | int in [2]
#      or
#      check_cas_user.rc | int in [0] and check_cas_user.stdout | int  in [1]
#      )
    tags:
      - casuser
  - name: Show whether the cas account exists or not
    debug: var=check_cas_user
    tags:
      - casuser

  - name: Inform user of skipped ulimits checks.
    debug:
      msg:
        - "the cas user ({{cas_user}}) does not seem to exist."
        - "that user would be used to check ulimit values. "
        - "this check will be skipped until {{cas_user}} exists"
    when: check_cas_user.rc | int != 0
    tags:
      - casuser



    ## block start
  - block:

    ## gather ulimit values - needs to be done as a regular user (cas)
    - name: Gather the current Ulimit values (soft nofile) for user "{{cas_user}}"
      become: yes
      become_user: "{{cas_user}}"
      shell: ulimit -n -S
      changed_when: False
      check_mode: no
      register: ulimit_soft_nofile

    - name: Gather the current Ulimit values (hard nofile) for user "{{cas_user}}"
      become: yes
      become_user: "{{cas_user}}"
      shell: ulimit -n -H
      changed_when: False
      check_mode: no
      register: ulimit_hard_nofile

    - name: Gather the current Ulimit values (soft nproc) for user "{{cas_user}}"
      become: yes
      become_user: "{{cas_user}}"
      shell: ulimit -u -S
      changed_when: False
      check_mode: no
      register: ulimit_soft_nproc

  ## display values
    - name: Show the value of ulimit_soft_nofile
      debug: var=ulimit_soft_nofile.stdout
    - name: Show the value of ulimit_hard_nofile
      debug: var=ulimit_hard_nofile.stdout
    - name: Show the value of ulimit_soft_nproc
      debug: var=ulimit_soft_nproc.stdout

  ## no updates needed nofile ulimit
    - block:
      - name: Show the message when no update is needed for nofile ulimit
        debug: msg="Your current nofile ulimit value ({{ulimit_soft_nofile.stdout}}(soft)/{{ulimit_hard_nofile.stdout}}(hard)) is greater or equal than desired value ({{ulimit_nofile_val}}) \n There is no need to udpate it"
      when: ulimit_soft_nofile is defined and (ulimit_soft_nofile.stdout | int >= ulimit_nofile_val | int or ulimit_hard_nofile.stdout | int >= ulimit_nofile_val | int )

  ## update nofile ulimit
    - block:
      - name: Show the message when updates are needed for nofile ulimit
        debug: msg="Your current nofile ulimit value ({{ulimit_soft_nofile.stdout}}(soft)/{{ulimit_hard_nofile.stdout}}(hard)) is less than desired value ({{ulimit_nofile_val}}) \n We will update the value"
      - name: Adjust limits in /etc/security/limits.d/va81.conf
        blockinfile:
          dest: /etc/security/limits.d/va81.conf
          backup: yes
          create: yes
          owner: root
          group: root
          mode: 0644
          marker: "#### -- {mark} VDMML 8.1 prereqs - ulimits - nofile"
          insertafter: EOF
          block: |
            @{{sas_group}}       -    nofile    {{ulimit_nofile_val}}
      when: ulimit_soft_nofile is defined and (ulimit_soft_nofile.stdout | int < ulimit_nofile_val |int or ulimit_hard_nofile.stdout | int < ulimit_nofile_val | int)





  ## no need to update nproc ulimits
    - block:
      - name: Show the message when no updates are needed for nproc ulimit
        debug: msg="Your current nproc ulimit value ({{ulimit_soft_nproc.stdout}}) is greater or equal than desired value ({{ulimit_soft_nproc_val}}) \n There is no need to udpate it"
      when: ulimit_soft_nproc is defined and ( (ulimit_soft_nproc.stdout | int) >= ulimit_soft_nproc_val | int)



  ## update nproc
    - block:
      - name: Show the message when updates are needed for nproc ulimit
        debug: msg="Your current nproc ulimit value ({{ulimit_soft_nproc.stdout}}) is less than desired value ({{ulimit_soft_nproc_val}}) \n We will update the value"
      - name: Adjust limits in /etc/security/limits.d/va81.conf
        blockinfile:
          dest: /etc/security/limits.d/va81.conf
          backup: yes
          create: yes
          owner: root
          group: root
          mode: 0644
          marker: "#### -- {mark} VDMML 8.1 prereqs - ulimits - nproc"
          insertafter: EOF
          block: |
            @{{sas_group}}       soft  nproc  {{ulimit_soft_nproc_val}}
            @{{sas_group}}       hard  nproc  {{ulimit_soft_nproc_val}}
      when: ulimit_soft_nproc is defined and ((ulimit_soft_nproc.stdout | int) < ulimit_soft_nproc_val | int)

    ## block end
    when: (check_cas_user.rc | int) == 0
    tags:
      - ulimits


####################################################################
## NTP
####################################################################

    ## block start
  - block:

    - name: Ensures NTP package is present
      yum:
        name: "{{ item }}"
        state: present
      with_items:
        - ntp

    - name: Check if ntp service exists
      stat: path=/usr/lib/systemd/system/ntpd.service
      register: ntpd_service

    - name: Ensures NTP service is started and enabled
      service:
        name: "{{ item }}"
        state: started
        enabled: yes
      when: ntpd_service.stat.exists
      with_items:
        - ntpd

    ## block end
    tags:
      - fixable
      - ntp




####################################################################
## Verify Internet access and bandwidth
####################################################################


### Networking Checks ###
  - block:

# test harness:
#   make it pass
#     ansible-playbook gel.readiness.yml --tags nics -e "use_pause=0" -e "max_num_nics=10"
#   make it fail
#     ansible-playbook gel.readiness.yml --tags nics -e "use_pause=0" -e "max_num_nics=0"
    - name: "Count the number of NICs (other than loopback)"
      shell: "ls -A /sys/class/net | grep -v lo | wc -l"
      changed_when: False
      check_mode: no
      register: numnics
      tags:
        - nics

    - name: Show the number of NICs found on the server
      debug: var=numnics.stdout
      tags:
        - nics


    - name: r that there only ({{max_num_nics|int}}) NICs or less on the server
      assert:
        that:
          - (numnics.stdout | int) <= (max_num_nics | int)
        msg:
          - "This server seems to have {{numnics.stdout|int}} Network Interfaces."
          - "It should only have {{max_num_nics|int}}."
          - "This will require more work to successfully deploy consul."
          - "Please read the following SAS Note for details on how to deal with it :<todo>"
          - "Add --skip-tags skipnicssfail to suppress this message."
      tags:
        - nics
        - skipifbelowspecs
        - skipnicssfail




    - name: "Trying to hit the SAS yum repository "
      shell: "curl -v -k https://{{item}}/"
      changed_when: False
      check_mode: no
      register: curl_sas_yum
      with_items: "{{sas_yum_urls}}"
      failed_when: "('Connect' in curl_sas_yum.stderr and item in curl_sas_yum.stderr ) != true"
      tags:
        - yum_repo

#   - debug: var=curl_sas_yum.results
#      tags:
#        - yum_repo


  ## Generic Speed Test of Connection to the Internet
    - name: Bandwidth to the Internet Check - Download 100 MB file
            - (the higher the better, otherwise downloading rpms will take long)
      shell: "time curl -o /dev/null  http://speedtest.sea01.softlayer.com/downloads/test100.zip 2>&1 | tail"
      check_mode: no
      changed_when: False
      register: time_speed_test
      tags:
        - bandwidth

    - name: Display bandwidth test results
      debug: var=time_speed_test.stdout_lines
      tags:
        - bandwidth


  ## DNS and Addressing
    - name: Hostname Ping check - (a server has to know itself by its hostname)
      shell: 'ping `hostname` -c 1'
      check_mode: no
      changed_when: False
      register: hostname_ping
      tags:
        - hostname

    - name: Show the results of the self ping test
      debug: var=hostname_ping.stdout_lines
      tags:
        - hostname

#    - name: Short Hostname Ping check
#            - (a server has to know itself by its short hostname as well)
#      shell: 'ping `hostname -s` -c 1'
#      check_mode: no
#      changed_when: False
#      register: shorthostname_ping
#      tags:
#        - hostname
#
#    - debug: var=shorthostname_ping.stdout_lines
#      tags:
#        - hostname

    ## block end
    tags:
      - networking
      - detectableonly



## DNS and Addressing

  - name: Various Hostname check
          - (hostname ; hostname -a ; hostname -A ; hostname -f ; hostname -i ; hostname -I)
    shell: "hostname ; hostname -a ; hostname -A ; hostname -f ; hostname -i ; hostname -I"
    check_mode: no
    changed_when: False
    register: various_hostname_test
    ignore_errors: yes
    tags:
      - hostname

  - name: Show the result of 'hostname ; hostname -a ; hostname -A ; hostname -f ; hostname -i ; hostname -I'
    debug: var=various_hostname_test.stdout_lines
    tags:
      - hostname

####################################################################
## Hostname checks
####################################################################


## Check /etc/hosts
  - name: Check /etc/hosts
    shell: "cat /etc/hosts"
    check_mode: no
    changed_when: False
    register: etc_hosts
    ignore_errors: yes
    tags:
      - hosts

  - name: Show the content of /etc/hosts
    debug: var=etc_hosts.stdout_lines
    tags:
      - hosts

####################################################################
## check that sas user has access to "service command" checks
####################################################################
  - name: check if the {{sas_user}} account exitst
    shell:  "getent passwd {{sas_user}} > /dev/null "
    changed_when: False
    check_mode: no
    register: check_sas_user
    ignore_errors: yes
    tags:
      - service_command
  - name: Show whether user 'sas' exists
    debug: var=check_sas_user
    tags:
      - service_command

  - name: Inform user of skipped check.
    debug:
      msg:
        - "the sas user ({{sas_user}}) does not seem to exist."
        - "we therefore can't access if it can use the service command "
        - "this check will be skipped until {{sas_user}} exists"
    when: check_sas_user.rc | int != 0
    tags:
      - service_command



  - name: Check if {{sas_user}} has access to service command
    shell: "which service"
    become: yes
    become_user: "{{sas_user}}"
    check_mode: no
    changed_when: False
    register: service_command
    failed_when: false
    when: check_sas_user.rc | int == 0
    tags:
      - service_command


  - name: Assert that {{sas_user}} can use service
    assert:
      that:
        - service_command.rc != 1
      msg:
        - "Apparently, {{sas_user}} can't use the service command"
        - "the result of 'which service' is:"
        - "      {{service_command.stderr}}"
    when: check_sas_user.rc | int == 0
    tags:
      - service_command


####################################################################
## e-mailing the results (optional)
####################################################################


  - name: Sending the log file by e-mail
    check_mode: no
    local_action: mail
      host="some_smtp_host"
      port=25
      subject="Ansible log file"
      body="Hello, \n please find the Ansible log file attached. \n \n Sincerely,  Ansible. "
      from="server@localhost"
      to="{{admin_email}}"
      attach="./deployment.log"
    when: admin_email is defined
    ignore_errors: yes
    tags:
      - mail
